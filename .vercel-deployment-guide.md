# Vercel Deployment Compatibility Guide

## Critical Rules for Code Generation

This project deploys to Vercel via the `staging` branch. All code must pass Vercel's build process without errors.

## Pre-Deployment Checklist

### 1. TypeScript Type Safety
- ✅ **ALWAYS** ensure all properties used in components exist in their type definitions
- ✅ When adding new properties (e.g., `code` in examples), update the corresponding TypeScript interfaces immediately
- ✅ Verify type definitions match actual usage across the entire codebase
- ✅ Check that all imported types are correctly defined

### 2. Event Handler Type Correctness
- ✅ `onChange` handlers receive `ChangeEvent<HTMLInputElement>`, NOT direct values
- ✅ **ALWAYS** extract values from events:
  - Use `e.target.checked` for checkboxes
  - Use `e.target.value` for inputs
  - Use `e.target.files` for file inputs
- ✅ **NEVER** pass event objects directly to functions expecting primitives (boolean, string, etc.)
- ✅ Example: `onChange={(e) => handleToggle(id, e.target.checked)}` ✅
- ✅ Example: `onChange={(checked) => handleToggle(id, checked)}` ❌

### 3. Build Verification Process
- ✅ **ALWAYS** run `npm run build` after making code changes
- ✅ Fix any TypeScript errors immediately before considering the task complete
- ✅ ESLint warnings don't fail builds, but TypeScript errors DO
- ✅ Verify the build completes successfully with exit code 0

### 4. Common Error Patterns to Avoid

#### Type Definition Mismatches
```typescript
// ❌ BAD: Property doesn't exist in type
examples: [{
  code: '<Component />'  // Error: 'code' does not exist in type
}]

// ✅ GOOD: Property added to type definition
// In types/documentation.ts:
examples?: Array<{
  code?: string;  // Added to type
  // ... other properties
}>
```

#### Event Handler Mismatches
```typescript
// ❌ BAD: Passing event as boolean
onChange={(checked) => handleToggle(id, checked)}

// ✅ GOOD: Extracting value from event
onChange={(e) => handleToggle(id, e.target.checked)}
```

## Workflow Integration

Since commits are made from Cursor's deploy tab:
1. **Before generating code**: Check existing type definitions
2. **While generating code**: Ensure types match usage
3. **After generating code**: Run `npm run build` to verify
4. **Before committing**: Confirm build passes successfully

## Automated Checks

The AI assistant should:
- Run `npm run build` after making TypeScript-related changes
- Verify all event handlers use correct event extraction patterns
- Check type definitions match component usage
- Fix any build errors before marking tasks as complete

## Deployment Context

- **Branch**: `staging`
- **Build Command**: `npm run build`
- **Type Checking**: Enabled (strict mode)
- **Failure Point**: Any TypeScript error will fail deployment

## Localhost Dev Server Reliability

**CRITICAL**: Never leave localhost broken or non-functional. Always ensure the dev server runs successfully.

### Dev Server Best Practices:
1. **Kill existing processes** before starting new dev server to avoid port conflicts
2. **Clear `.next` cache** if experiencing strange runtime errors
3. **Add `'use client'` directive** to all components using hooks, events, or browser APIs
4. **Verify server starts** successfully after code changes

### Quick Dev Server Fixes:
```bash
# Kill all Next.js processes
pkill -f "next dev" || true
lsof -ti:3000 | xargs kill -9 2>/dev/null || true

# Clear cache and restart
rm -rf .next && npm run dev

# Verify server is running
curl -s http://localhost:3000 > /dev/null && echo "✓ Server OK" || echo "✗ Server failed"
```

### Common Localhost Issues:
- Multiple dev servers running (port 3000 conflict)
- Missing `'use client'` in interactive components
- Stale `.next` cache causing runtime errors
- Server-side components importing client-only code

---

**Last Updated**: After fixing CheckboxDocumentation code property, ToDosAccordion onChange handler issues, and localhost reliability problems
